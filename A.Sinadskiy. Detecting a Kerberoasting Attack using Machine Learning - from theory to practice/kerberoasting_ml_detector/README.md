# Обнаружение атаки Kerberoasting при помощи методов машинного обучения
Источник списка SPN: https://adsecurity.org/?page_id=183

## Стенд
Все машины развернуты в Yandex.Cloud. ОС на всех ВМ - Ubuntu 24.04. Доступ к ВМ - через SSH при помощи публичного ключа
KDC (domain-controller): 10.129.0.25 (внешний 89.169.164.147)

Сервер приложений (app-server): 10.129.0.11 (внешний 158.160.3.10)

Клиент (client): 10.129.0.31 (внешний 89.169.172.134)
![схема стенда.png](%D1%81%D1%85%D0%B5%D0%BC%D0%B0%20%D1%81%D1%82%D0%B5%D0%BD%D0%B4%D0%B0.png)

## Перед началом
Необходимо установить необходимые Python-библиотеки:
```shell
pip install -r requirements.txt
```
На новых версиях ОС Linux (например, на Ubuntu 24.04) pip выдаст ошибку externally_managed_environment. В этом случае
придется устанавливать через системный менеджер пакетов. Например, на Ubuntu:
```shell
sudo apt install python3-scapy python3-schedule python3-sklearn python3-scipy python3-numpy
```

## Средство обнаружения
Основной результат практики - средство обнаружения атаки Kerberoasting. Запускается на KDC.

Реализовано скриптом на языке Python. Использует сниффинг трафика на определенном сетевом интерфейсе
(при помощи библиотеки scapy), обнаруживает в трафике определенные видов Kerberos-пакетов (AS_REQ, TGS_REQ) и
сохраняет определенную информацию о пакетах для дальнейшего анализа при помощи методов машинного обучения.

### Запуск
Запуск требует привилегий администратора - без них сниффинг трафика будет невозможен.

Если ОС UNIX-подобная, то лучше всего запускать средство обнаружения в качестве службы, чтобы оно запускалось вместе с ОС.
Для этого нужно создать (от имени суперпользователя) файл /etc/systemd/system/<имя службы>.service со следующим
содержимым:
```
[Unit]
Description=<ваше описание>

[Service]
User=root
WorkingDirectory=<полный путь директории со средством обнаружения>
ExecStart=<полный путь директории со средством обнаружения>/kerberoasting_detector --iface <сетевой интерфейс>

[Install]
WantedBy=multi-user.target
```
После создания службы для запуска (а также для запуска при старте ОС) нужно сделать следующее:
```shell
sudo systemctl daemon-reload
sudo service <имя службы> enable --now
```

Запуск из терминала (с правами суперпользователя):
```shell
chmod a+x kerberoasting_detector
./kerberoasting_detector [-h] [--iface IFACE]
```
* iface - сетевой интерфейс, на котором будет делаться сниффинг

### Логика работы
Признаками атаки считаем:
* Использование слабого алгоритма шифрования RC4 (etype=0x17) (легко обнаруживается сигнатурным методом, добавлен)
* Большое количество TGS_REQ запросов от одного клиента в короткий промежуток времени (flood)
* TGS_REQ запросы от одного клиента, повторяющиеся в фиксированный временной интервал (обнаружение при >= 50
повторениях)

При запуске средства обнаружения происходит чтение датасета datasets/sample.csv. Этот датасет размечен двумя бинарными 
метками: 
* flood_mark - большое количество TGS_REQ запросов с одного хоста
* fixed_time_mark - атака с фиксированным интервалом

После чтения датасета и группировки данных проводится обучение, по результатам которого делается анализ правильности 
обучения (соответствия его результатов меткам из датасета) и запись результатов в файл. Методы обучения:
* Для flood используется One-Class Support Vector Machine (One-Class SVM) с параметрами nu=1e-5, gamma=0.1.
В качестве вектора используется пара (<количество запросов в секунду>, <среднее количество запрашиваемых служб на 1
клиента>), которая находится для каждой секунды, в течение которой произошел TGS_REQ или AS_REQ; там, где нашлась
аномалия, SVM вернет -1, в остальных случаях вернется 1. Данные из датасета группируются таким образом, что, если в
конкретную секунду в датасете нашлись запросы c flood_mark=1, то для этой секунды ожидаемое значение SVM должно быть -1,
в противном случае - 1. Метрики обучения записываются в flood_metrics.txt
* Для атаки с фиксированным интервалом используется локальный уровень выбросов (Local Outlier Factor, LOF). Для обучения
используется одномерный вектор, состоящий из числового timestamp секунды; там, где нашлась аномалия, LOF вернет -1,
в остальных случаях вернется 1. Дальше смотрим при помощи критерия Колмогорова-Смирнова, что для пакетов, которые по LOF
считаются аномальными, наблюдается равномерное распределение (при p-value>=0.05). Если наблюдается, то считаем, что
в эту секунду произошла аномалия и возвращаем -1; в противном случае возвращаем 1. Данные из датасета группируются таким
образом, что, если в конкретную секунду в датасете нашлись запросы c fixed_time_mark=1, то для этой секунды ожидаемое
значение аномалии должно быть -1, в противном случае - 1. Метрики обучения записываются в fixed_time_metrics.txt

Информация из всех приходящих AS_REQ и TGS_REQ запросов сохраняется в три хранилища:
* records - полная информация о всех запросах (включает в себя время, тип запроса, IP-адрес клиента, имя клиента, имя
службы и realm)
* frequencies - информация о запросах в определенные секунды: количество запросов и пары "IP-адрес клиента-запрашиваемая
служба"
* user_timestamps - информация о том, какой пользователь, в какую секунду и сколько запросов сделал.

Раз в секунду (чтобы приблизиться к обнаружению атаки в реальном времени) мы делаем анализ. Если в последнюю секунду
никаких TGS_REQ и AS_REQ не произошло, то ничего не делаем. Если произошло, то анализируем тем же способом, что при
запуске приложения,
данные в хранилищах и смотрим, не считаются ли данные для последней секунды аномалией. Если считаются - сигнализируем,
записывая в syslog сообщение с уровнем WARN. Сообщение зависит от атаки:
* flood - "Обнаружено аномально большое количество пакетов."
* Атака с фиксированным интервалом - "Обнаружена подозрительная серия регулярных запросов с хоста <скомпрометированный
клиент>"

Также можно будет увидеть сообщение "Обнаружен пакет, зашифрованный алгоритмом RC4.", если пришел пакет, который ожидает
шифрование по RC4.

При завершении работы приложения, а также каждый день в полночь будет делаться дамп запросов, сделанных за последние
сутки. Этот датасет можно будет проанализировать, разметить и дополнить этими данными уже существующий датасет. После
дампа данные за последние сутки будут удалены из хранилищ.

## Средство симуляции Kerberoasting
Для проверки работоспособности средства обнаружения нужно уметь осуществить атаку (или ее симуляцию). Для этого
реализован скрипт kerberoast

### Запуск
Скрипт запускается на клиенте от имени скомпрометированного пользователя, ранее прошедшего Kerberos-аутентификацию
```shell
chmod a+x kerberoast
./kerberoast [-h] --domain DOMAIN [--number_of_tgs NUMBER_OF_TGS] [--freq FREQ]
```
* domain - обязательный параметр, содержит информацию о realm
* number_of_tgs - количество TGS-запросов в рамках атаки; по умолчанию 100
* freq - фиксированный интервал TGS_REQ запросов; если не указан - осуществляется flood-атака

### Логика работы
Атака осуществляется при помощи вызова команды kvno <случайно выбранный SPN>/<имя realm>. Проверялось только на Linux.

## Средство генерации датасета
Для получения датасета, в котором будут содержаться данные для обнаружения Kerberoast, реализован скрипт create_dataset.
Т.к. датасет datasets/sample.csv не содержится в файлах проекта, его нужно сгенерировать этим скриптом (или перенести
уже готовый датасет из другого места). 

### Запуск
```shell
chmod a+x create_dataset
./create_dataset
```

### Логика работы
Создается датасет, в рамках которого описан трафик около 1000 пользователей, имеющих доступ к определенному объекту КИИ.
Датасет содержит:
* нормальный трафик
* flood-атаку
* атаку с фиксированным интервалом

Пакеты, отправленные в рамках атаки, размечаются в датасете. Если flood, то flood_mark=1, если атака с фиксированным
интервалом - fixed_time_mark=1